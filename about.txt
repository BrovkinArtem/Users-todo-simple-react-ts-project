1.1 Типизация пропсов, простые значения
  Мы создали компонент Card.tsx и каждый пропс у него нужно типизировать
  Допустим мы должны получить width

  Для этого перед самим компонентом создаём типизацию:
  interface CardProps {
      width: string;
  }

  И самому пропсу присваиваем этот тип
  const Card = ({width}: CardProps)

  Если мы хотим в каком либо компоненте разместить новый компонент внутри,
  то нужно типизировать что будет в children:
  children: React.ReactNode; Также возможно так:
  children: React.ReactElement;

  Разница в следующем:
  ReactNode → всё, что можно положить в JSX (строки, числа, элементы, массивы, null и т.д.).
  ReactElement → конкретно JSX-элемент (например <div />).

  В новой версии эту Фишку убрали и FC теперь бесполезен, всё равно всё указывать вручную
  "
    Но на деле, профессиональнее будет сделать так:
    Указать чем компонент будет являться:
    const Card: React.FC<CardProps>
    FC - FunctionalComponent - Наш компонент является функциональным:
      Принимает пропсы и возвращает элементы React
  "

  Если у нас есть пропс, который ожидает литералы (разновидность компонента),
  то для него мы подготавливаем enum

  Таким образом отличный + типизации это автокомплит, который помогает нам быстрее
  заполнять данные




1.2 Типизация пропсов, сложные значения
  А что если хотим передать функцию?
  Пишем что будет отдавать и получать базово, в нашем случае ничего
  onClick: () => void,
  onClick: (Принимает) => Отдаёт
  onClick: (num: number) => number

  объявляем:
  onClick={onClick}

  Передаём функцию через App.tsx:
  onClick={() => console.log('click')}




2. types
  Мы создали папку types, чтобы записывать туда глобальные типы,
  которые могут использоваться по всему проекту

  Если в типе есть лишняя вложенность, выносим её создавая новый интерфейс
  I перед названием сообщает нам что это интерфейс
  Итог:
  interface IAddress {
    street: string;
    city: string;
    zipcode: string;
  }

  export interface IUser {
    id: number;
    name: string;
    email: string;
    address: IAddress;
  }

  А вот так принимаем инфу:
  interface UserListProps {
    users: IUser[]
  }



3. Состояния / ответ от сервера:
  Это мы тоже должны контролировать, для этого используем дженерики:
  Состояние:
  const [users, setUsers] = useState<IUser[]>([])

  Ответ от сервера:
  const response = await axios.get<IUser[]>('https://jsonplaceholder.typicode.com/users')
  setUsers(response.data)





4. Переиспользуемые компоненты
  Можно заметить что вместо UserList мы стали использовать List
  Так как UserList получает только одни данные, users
  А мы хотим сделать такой список, который мог бы обрабатывать разные данные
  Для этого мы указываем тип принимаемых данных в пропсах через дженерик,
  а также какие данные (элементы списка), будут отрисовываться:
  interface ListProps<T> {
    items: T[];
    renderItem: (item: T) => React.ReactNode
  }

  Ну и саму стрелочную функцию мы сделали как function declarationЖ
  export default function List<T>(props: ListProps<T>)

  И по сути renderItem, то же самое что child,
  берём этот список обрабатываем и рисуем информацию:
  <div>
    {props.items.map(props.renderItem)}
  </div>

  В app.tsx же, передаём информацию (массив users в нашем случае)
   и что, и как будем выводить - UserItem:
  <List
    items={users}
    renderItem={(user: IUser) => <UserItem user={user} key={user.id}/>
  }/>

  Позже мы переиспользуем этот список и будем использовать его для указания todo





5. Типизация событий (Events)
  У React дополнительно event оборачивается в синтетик event,
  однако мы не знаем к чем там можно обращаться и это нужно смотреть в документации
  Но мы можем явно указать тип, так как работаем со слушателем события onChange:
  const changeHandler = (e: React.ChangeEvent) => {

  }
  а также все события которые связаны с мышью помечаем так:
  const clickHandler = (e: React.MouseEvent) => {

  }
  Как итог мы видим через . все методы которые можно применить

  Опять же кажется зачем это? Но суть типизации от части такова, чтобы приводить
  всё к очевидному, с целью получения автокомплита и обережения нашего кода в будущем

  Но так как таргеты и прочее могут быть тоже разными, поэтому мы обязаны указать дженерик
  Указывается это так <HTML...Element>, есть для всех элементов,
  в нашем случае:
  e: React.ChangeEvent<HTMLInputElement>
  Таким образом в target через . можно выбрать только те поля которые относятся к инпуту

  Там же мы опробовали и другие эвенты (EventsExample.tsx)

  С неуправляемыми эвентами всё то же самое, только используем useRef и указываем дженерик элемент:
  const inputRef = useRef<HTMLInputElement>(null)




6. Типизация react router DOM
  Ничего особого на самом деле, короче понять можно самому